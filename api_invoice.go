/*
OpenAPI UniBee

This is UniBee api server

API version: buildtime:202404131246 
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package unibee

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"reflect"
)


// InvoiceService Invoice service
type InvoiceService service

type InvoiceInvoiceCancelPostRequest struct {
	ctx context.Context
	ApiService *InvoiceService
	unibeeApiMerchantInvoiceCancelReq *UnibeeApiMerchantInvoiceCancelReq
}

func (r InvoiceInvoiceCancelPostRequest) UnibeeApiMerchantInvoiceCancelReq(unibeeApiMerchantInvoiceCancelReq UnibeeApiMerchantInvoiceCancelReq) InvoiceInvoiceCancelPostRequest {
	r.unibeeApiMerchantInvoiceCancelReq = &unibeeApiMerchantInvoiceCancelReq
	return r
}

func (r InvoiceInvoiceCancelPostRequest) Execute() (*MerchantAuthSsoLoginOTPPost200Response, *http.Response, error) {
	return r.ApiService.InvoiceCancelPostExecute(r)
}

/*
InvoiceCancelPost Admin Cancel Invoice Of Processing Status

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return InvoiceInvoiceCancelPostRequest
*/
func (a *InvoiceService) InvoiceCancelPost(ctx context.Context) InvoiceInvoiceCancelPostRequest {
	return InvoiceInvoiceCancelPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MerchantAuthSsoLoginOTPPost200Response
func (a *InvoiceService) InvoiceCancelPostExecute(r InvoiceInvoiceCancelPostRequest) (*MerchantAuthSsoLoginOTPPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MerchantAuthSsoLoginOTPPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InvoiceService.InvoiceCancelPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/merchant/invoice/cancel"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.unibeeApiMerchantInvoiceCancelReq == nil {
		return localVarReturnValue, nil, reportError("unibeeApiMerchantInvoiceCancelReq is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.unibeeApiMerchantInvoiceCancelReq
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type InvoiceInvoiceDeletePostRequest struct {
	ctx context.Context
	ApiService *InvoiceService
	unibeeApiMerchantInvoiceDeleteReq *UnibeeApiMerchantInvoiceDeleteReq
}

func (r InvoiceInvoiceDeletePostRequest) UnibeeApiMerchantInvoiceDeleteReq(unibeeApiMerchantInvoiceDeleteReq UnibeeApiMerchantInvoiceDeleteReq) InvoiceInvoiceDeletePostRequest {
	r.unibeeApiMerchantInvoiceDeleteReq = &unibeeApiMerchantInvoiceDeleteReq
	return r
}

func (r InvoiceInvoiceDeletePostRequest) Execute() (*MerchantAuthSsoLoginOTPPost200Response, *http.Response, error) {
	return r.ApiService.InvoiceDeletePostExecute(r)
}

/*
InvoiceDeletePost Admin Delete Invoice Of Pending Status

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return InvoiceInvoiceDeletePostRequest
*/
func (a *InvoiceService) InvoiceDeletePost(ctx context.Context) InvoiceInvoiceDeletePostRequest {
	return InvoiceInvoiceDeletePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MerchantAuthSsoLoginOTPPost200Response
func (a *InvoiceService) InvoiceDeletePostExecute(r InvoiceInvoiceDeletePostRequest) (*MerchantAuthSsoLoginOTPPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MerchantAuthSsoLoginOTPPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InvoiceService.InvoiceDeletePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/merchant/invoice/delete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.unibeeApiMerchantInvoiceDeleteReq == nil {
		return localVarReturnValue, nil, reportError("unibeeApiMerchantInvoiceDeleteReq is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.unibeeApiMerchantInvoiceDeleteReq
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type InvoiceInvoiceDetailGetRequest struct {
	ctx context.Context
	ApiService *InvoiceService
	invoiceId *string
}

// Invoice ID
func (r InvoiceInvoiceDetailGetRequest) InvoiceId(invoiceId string) InvoiceInvoiceDetailGetRequest {
	r.invoiceId = &invoiceId
	return r
}

func (r InvoiceInvoiceDetailGetRequest) Execute() (*MerchantInvoiceDetailGet200Response, *http.Response, error) {
	return r.ApiService.InvoiceDetailGetExecute(r)
}

/*
InvoiceDetailGet Invoice Detail

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return InvoiceInvoiceDetailGetRequest
*/
func (a *InvoiceService) InvoiceDetailGet(ctx context.Context) InvoiceInvoiceDetailGetRequest {
	return InvoiceInvoiceDetailGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MerchantInvoiceDetailGet200Response
func (a *InvoiceService) InvoiceDetailGetExecute(r InvoiceInvoiceDetailGetRequest) (*MerchantInvoiceDetailGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MerchantInvoiceDetailGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InvoiceService.InvoiceDetailGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/merchant/invoice/detail"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.invoiceId == nil {
		return localVarReturnValue, nil, reportError("invoiceId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "invoiceId", r.invoiceId, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type InvoiceInvoiceDetailPostRequest struct {
	ctx context.Context
	ApiService *InvoiceService
	unibeeApiMerchantInvoiceDetailReq *UnibeeApiMerchantInvoiceDetailReq
}

func (r InvoiceInvoiceDetailPostRequest) UnibeeApiMerchantInvoiceDetailReq(unibeeApiMerchantInvoiceDetailReq UnibeeApiMerchantInvoiceDetailReq) InvoiceInvoiceDetailPostRequest {
	r.unibeeApiMerchantInvoiceDetailReq = &unibeeApiMerchantInvoiceDetailReq
	return r
}

func (r InvoiceInvoiceDetailPostRequest) Execute() (*MerchantInvoiceDetailGet200Response, *http.Response, error) {
	return r.ApiService.InvoiceDetailPostExecute(r)
}

/*
InvoiceDetailPost Invoice Detail

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return InvoiceInvoiceDetailPostRequest
*/
func (a *InvoiceService) InvoiceDetailPost(ctx context.Context) InvoiceInvoiceDetailPostRequest {
	return InvoiceInvoiceDetailPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MerchantInvoiceDetailGet200Response
func (a *InvoiceService) InvoiceDetailPostExecute(r InvoiceInvoiceDetailPostRequest) (*MerchantInvoiceDetailGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MerchantInvoiceDetailGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InvoiceService.InvoiceDetailPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/merchant/invoice/detail"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.unibeeApiMerchantInvoiceDetailReq == nil {
		return localVarReturnValue, nil, reportError("unibeeApiMerchantInvoiceDetailReq is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.unibeeApiMerchantInvoiceDetailReq
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type InvoiceInvoiceEditPostRequest struct {
	ctx context.Context
	ApiService *InvoiceService
	unibeeApiMerchantInvoiceEditReq *UnibeeApiMerchantInvoiceEditReq
}

func (r InvoiceInvoiceEditPostRequest) UnibeeApiMerchantInvoiceEditReq(unibeeApiMerchantInvoiceEditReq UnibeeApiMerchantInvoiceEditReq) InvoiceInvoiceEditPostRequest {
	r.unibeeApiMerchantInvoiceEditReq = &unibeeApiMerchantInvoiceEditReq
	return r
}

func (r InvoiceInvoiceEditPostRequest) Execute() (*MerchantInvoiceDetailGet200Response, *http.Response, error) {
	return r.ApiService.InvoiceEditPostExecute(r)
}

/*
InvoiceEditPost Admin Edit Invoice

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return InvoiceInvoiceEditPostRequest
*/
func (a *InvoiceService) InvoiceEditPost(ctx context.Context) InvoiceInvoiceEditPostRequest {
	return InvoiceInvoiceEditPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MerchantInvoiceDetailGet200Response
func (a *InvoiceService) InvoiceEditPostExecute(r InvoiceInvoiceEditPostRequest) (*MerchantInvoiceDetailGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MerchantInvoiceDetailGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InvoiceService.InvoiceEditPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/merchant/invoice/edit"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.unibeeApiMerchantInvoiceEditReq == nil {
		return localVarReturnValue, nil, reportError("unibeeApiMerchantInvoiceEditReq is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.unibeeApiMerchantInvoiceEditReq
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type InvoiceInvoiceFinishPostRequest struct {
	ctx context.Context
	ApiService *InvoiceService
	unibeeApiMerchantInvoiceFinishReq *UnibeeApiMerchantInvoiceFinishReq
}

func (r InvoiceInvoiceFinishPostRequest) UnibeeApiMerchantInvoiceFinishReq(unibeeApiMerchantInvoiceFinishReq UnibeeApiMerchantInvoiceFinishReq) InvoiceInvoiceFinishPostRequest {
	r.unibeeApiMerchantInvoiceFinishReq = &unibeeApiMerchantInvoiceFinishReq
	return r
}

func (r InvoiceInvoiceFinishPostRequest) Execute() (*MerchantInvoiceFinishPost200Response, *http.Response, error) {
	return r.ApiService.InvoiceFinishPostExecute(r)
}

/*
InvoiceFinishPost Admin Finish Invoice，Generate Pay Link

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return InvoiceInvoiceFinishPostRequest
*/
func (a *InvoiceService) InvoiceFinishPost(ctx context.Context) InvoiceInvoiceFinishPostRequest {
	return InvoiceInvoiceFinishPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MerchantInvoiceFinishPost200Response
func (a *InvoiceService) InvoiceFinishPostExecute(r InvoiceInvoiceFinishPostRequest) (*MerchantInvoiceFinishPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MerchantInvoiceFinishPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InvoiceService.InvoiceFinishPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/merchant/invoice/finish"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.unibeeApiMerchantInvoiceFinishReq == nil {
		return localVarReturnValue, nil, reportError("unibeeApiMerchantInvoiceFinishReq is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.unibeeApiMerchantInvoiceFinishReq
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type InvoiceInvoiceListGetRequest struct {
	ctx context.Context
	ApiService *InvoiceService
	firstName *string
	lastName *string
	currency *string
	status *[]int32
	amountStart *int64
	amountEnd *int64
	userId *int32
	sendEmail *string
	sortField *string
	sortType *string
	deleteInclude *bool
	page *int32
	count *int32
}

// FirstName
func (r InvoiceInvoiceListGetRequest) FirstName(firstName string) InvoiceInvoiceListGetRequest {
	r.firstName = &firstName
	return r
}

// LastName
func (r InvoiceInvoiceListGetRequest) LastName(lastName string) InvoiceInvoiceListGetRequest {
	r.lastName = &lastName
	return r
}

// Currency
func (r InvoiceInvoiceListGetRequest) Currency(currency string) InvoiceInvoiceListGetRequest {
	r.currency = &currency
	return r
}

// Status, 1-pending｜2-processing｜3-paid | 4-failed | 5-cancelled
func (r InvoiceInvoiceListGetRequest) Status(status []int32) InvoiceInvoiceListGetRequest {
	r.status = &status
	return r
}

// AmountStart
func (r InvoiceInvoiceListGetRequest) AmountStart(amountStart int64) InvoiceInvoiceListGetRequest {
	r.amountStart = &amountStart
	return r
}

// AmountEnd
func (r InvoiceInvoiceListGetRequest) AmountEnd(amountEnd int64) InvoiceInvoiceListGetRequest {
	r.amountEnd = &amountEnd
	return r
}

// UserId Filter, Default Filter All
func (r InvoiceInvoiceListGetRequest) UserId(userId int32) InvoiceInvoiceListGetRequest {
	r.userId = &userId
	return r
}

// SendEmail Filter , Default Filter All
func (r InvoiceInvoiceListGetRequest) SendEmail(sendEmail string) InvoiceInvoiceListGetRequest {
	r.sendEmail = &sendEmail
	return r
}

// Filter，em. invoice_id|gmt_create|gmt_modify|period_end|total_amount，Default gmt_modify
func (r InvoiceInvoiceListGetRequest) SortField(sortField string) InvoiceInvoiceListGetRequest {
	r.sortField = &sortField
	return r
}

// Sort，asc|desc，Default desc
func (r InvoiceInvoiceListGetRequest) SortType(sortType string) InvoiceInvoiceListGetRequest {
	r.sortType = &sortType
	return r
}

// Deleted Involved，Need Admin
func (r InvoiceInvoiceListGetRequest) DeleteInclude(deleteInclude bool) InvoiceInvoiceListGetRequest {
	r.deleteInclude = &deleteInclude
	return r
}

// Page, Start 0
func (r InvoiceInvoiceListGetRequest) Page(page int32) InvoiceInvoiceListGetRequest {
	r.page = &page
	return r
}

// Count By Page
func (r InvoiceInvoiceListGetRequest) Count(count int32) InvoiceInvoiceListGetRequest {
	r.count = &count
	return r
}

func (r InvoiceInvoiceListGetRequest) Execute() (*MerchantInvoiceListGet200Response, *http.Response, error) {
	return r.ApiService.InvoiceListGetExecute(r)
}

/*
InvoiceListGet Invoice List

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return InvoiceInvoiceListGetRequest
*/
func (a *InvoiceService) InvoiceListGet(ctx context.Context) InvoiceInvoiceListGetRequest {
	return InvoiceInvoiceListGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MerchantInvoiceListGet200Response
func (a *InvoiceService) InvoiceListGetExecute(r InvoiceInvoiceListGetRequest) (*MerchantInvoiceListGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MerchantInvoiceListGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InvoiceService.InvoiceListGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/merchant/invoice/list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.firstName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "firstName", r.firstName, "")
	}
	if r.lastName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lastName", r.lastName, "")
	}
	if r.currency != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currency", r.currency, "")
	}
	if r.status != nil {
		t := *r.status
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status", t, "multi")
		}
	}
	if r.amountStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "amountStart", r.amountStart, "")
	}
	if r.amountEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "amountEnd", r.amountEnd, "")
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userId", r.userId, "")
	}
	if r.sendEmail != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sendEmail", r.sendEmail, "")
	}
	if r.sortField != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortField", r.sortField, "")
	}
	if r.sortType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortType", r.sortType, "")
	}
	if r.deleteInclude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deleteInclude", r.deleteInclude, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type InvoiceInvoiceListPostRequest struct {
	ctx context.Context
	ApiService *InvoiceService
	unibeeApiMerchantInvoiceListReq *UnibeeApiMerchantInvoiceListReq
}

func (r InvoiceInvoiceListPostRequest) UnibeeApiMerchantInvoiceListReq(unibeeApiMerchantInvoiceListReq UnibeeApiMerchantInvoiceListReq) InvoiceInvoiceListPostRequest {
	r.unibeeApiMerchantInvoiceListReq = &unibeeApiMerchantInvoiceListReq
	return r
}

func (r InvoiceInvoiceListPostRequest) Execute() (*MerchantInvoiceListGet200Response, *http.Response, error) {
	return r.ApiService.InvoiceListPostExecute(r)
}

/*
InvoiceListPost Invoice List

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return InvoiceInvoiceListPostRequest
*/
func (a *InvoiceService) InvoiceListPost(ctx context.Context) InvoiceInvoiceListPostRequest {
	return InvoiceInvoiceListPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MerchantInvoiceListGet200Response
func (a *InvoiceService) InvoiceListPostExecute(r InvoiceInvoiceListPostRequest) (*MerchantInvoiceListGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MerchantInvoiceListGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InvoiceService.InvoiceListPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/merchant/invoice/list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.unibeeApiMerchantInvoiceListReq == nil {
		return localVarReturnValue, nil, reportError("unibeeApiMerchantInvoiceListReq is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.unibeeApiMerchantInvoiceListReq
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type InvoiceInvoiceMarkRefundPostRequest struct {
	ctx context.Context
	ApiService *InvoiceService
	unibeeApiMerchantInvoiceMarkRefundReq *UnibeeApiMerchantInvoiceMarkRefundReq
}

func (r InvoiceInvoiceMarkRefundPostRequest) UnibeeApiMerchantInvoiceMarkRefundReq(unibeeApiMerchantInvoiceMarkRefundReq UnibeeApiMerchantInvoiceMarkRefundReq) InvoiceInvoiceMarkRefundPostRequest {
	r.unibeeApiMerchantInvoiceMarkRefundReq = &unibeeApiMerchantInvoiceMarkRefundReq
	return r
}

func (r InvoiceInvoiceMarkRefundPostRequest) Execute() (*MerchantInvoiceMarkRefundPost200Response, *http.Response, error) {
	return r.ApiService.InvoiceMarkRefundPostExecute(r)
}

/*
InvoiceMarkRefundPost Admin Mark Refund For Invoice

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return InvoiceInvoiceMarkRefundPostRequest
*/
func (a *InvoiceService) InvoiceMarkRefundPost(ctx context.Context) InvoiceInvoiceMarkRefundPostRequest {
	return InvoiceInvoiceMarkRefundPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MerchantInvoiceMarkRefundPost200Response
func (a *InvoiceService) InvoiceMarkRefundPostExecute(r InvoiceInvoiceMarkRefundPostRequest) (*MerchantInvoiceMarkRefundPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MerchantInvoiceMarkRefundPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InvoiceService.InvoiceMarkRefundPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/merchant/invoice/mark_refund"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.unibeeApiMerchantInvoiceMarkRefundReq == nil {
		return localVarReturnValue, nil, reportError("unibeeApiMerchantInvoiceMarkRefundReq is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.unibeeApiMerchantInvoiceMarkRefundReq
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type InvoiceInvoiceNewPostRequest struct {
	ctx context.Context
	ApiService *InvoiceService
	unibeeApiMerchantInvoiceNewReq *UnibeeApiMerchantInvoiceNewReq
}

func (r InvoiceInvoiceNewPostRequest) UnibeeApiMerchantInvoiceNewReq(unibeeApiMerchantInvoiceNewReq UnibeeApiMerchantInvoiceNewReq) InvoiceInvoiceNewPostRequest {
	r.unibeeApiMerchantInvoiceNewReq = &unibeeApiMerchantInvoiceNewReq
	return r
}

func (r InvoiceInvoiceNewPostRequest) Execute() (*MerchantInvoiceDetailGet200Response, *http.Response, error) {
	return r.ApiService.InvoiceNewPostExecute(r)
}

/*
InvoiceNewPost Admin Create New Invoice

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return InvoiceInvoiceNewPostRequest
*/
func (a *InvoiceService) InvoiceNewPost(ctx context.Context) InvoiceInvoiceNewPostRequest {
	return InvoiceInvoiceNewPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MerchantInvoiceDetailGet200Response
func (a *InvoiceService) InvoiceNewPostExecute(r InvoiceInvoiceNewPostRequest) (*MerchantInvoiceDetailGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MerchantInvoiceDetailGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InvoiceService.InvoiceNewPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/merchant/invoice/new"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.unibeeApiMerchantInvoiceNewReq == nil {
		return localVarReturnValue, nil, reportError("unibeeApiMerchantInvoiceNewReq is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.unibeeApiMerchantInvoiceNewReq
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type InvoiceInvoicePdfGeneratePostRequest struct {
	ctx context.Context
	ApiService *InvoiceService
	unibeeApiMerchantInvoicePdfGenerateReq *UnibeeApiMerchantInvoicePdfGenerateReq
}

func (r InvoiceInvoicePdfGeneratePostRequest) UnibeeApiMerchantInvoicePdfGenerateReq(unibeeApiMerchantInvoicePdfGenerateReq UnibeeApiMerchantInvoicePdfGenerateReq) InvoiceInvoicePdfGeneratePostRequest {
	r.unibeeApiMerchantInvoicePdfGenerateReq = &unibeeApiMerchantInvoicePdfGenerateReq
	return r
}

func (r InvoiceInvoicePdfGeneratePostRequest) Execute() (*MerchantAuthSsoLoginOTPPost200Response, *http.Response, error) {
	return r.ApiService.InvoicePdfGeneratePostExecute(r)
}

/*
InvoicePdfGeneratePost Admin Generate Merchant Invoice pdf

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return InvoiceInvoicePdfGeneratePostRequest
*/
func (a *InvoiceService) InvoicePdfGeneratePost(ctx context.Context) InvoiceInvoicePdfGeneratePostRequest {
	return InvoiceInvoicePdfGeneratePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MerchantAuthSsoLoginOTPPost200Response
func (a *InvoiceService) InvoicePdfGeneratePostExecute(r InvoiceInvoicePdfGeneratePostRequest) (*MerchantAuthSsoLoginOTPPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MerchantAuthSsoLoginOTPPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InvoiceService.InvoicePdfGeneratePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/merchant/invoice/pdf_generate"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.unibeeApiMerchantInvoicePdfGenerateReq == nil {
		return localVarReturnValue, nil, reportError("unibeeApiMerchantInvoicePdfGenerateReq is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.unibeeApiMerchantInvoicePdfGenerateReq
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type InvoiceInvoiceReconvertCryptoAndSendEmailPostRequest struct {
	ctx context.Context
	ApiService *InvoiceService
	unibeeApiMerchantInvoiceReconvertCryptoAndSendReq *UnibeeApiMerchantInvoiceReconvertCryptoAndSendReq
}

func (r InvoiceInvoiceReconvertCryptoAndSendEmailPostRequest) UnibeeApiMerchantInvoiceReconvertCryptoAndSendReq(unibeeApiMerchantInvoiceReconvertCryptoAndSendReq UnibeeApiMerchantInvoiceReconvertCryptoAndSendReq) InvoiceInvoiceReconvertCryptoAndSendEmailPostRequest {
	r.unibeeApiMerchantInvoiceReconvertCryptoAndSendReq = &unibeeApiMerchantInvoiceReconvertCryptoAndSendReq
	return r
}

func (r InvoiceInvoiceReconvertCryptoAndSendEmailPostRequest) Execute() (*MerchantAuthSsoLoginOTPPost200Response, *http.Response, error) {
	return r.ApiService.InvoiceReconvertCryptoAndSendEmailPostExecute(r)
}

/*
InvoiceReconvertCryptoAndSendEmailPost Admin Reconvert Crypto Data and Send Invoice Email to User

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return InvoiceInvoiceReconvertCryptoAndSendEmailPostRequest
*/
func (a *InvoiceService) InvoiceReconvertCryptoAndSendEmailPost(ctx context.Context) InvoiceInvoiceReconvertCryptoAndSendEmailPostRequest {
	return InvoiceInvoiceReconvertCryptoAndSendEmailPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MerchantAuthSsoLoginOTPPost200Response
func (a *InvoiceService) InvoiceReconvertCryptoAndSendEmailPostExecute(r InvoiceInvoiceReconvertCryptoAndSendEmailPostRequest) (*MerchantAuthSsoLoginOTPPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MerchantAuthSsoLoginOTPPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InvoiceService.InvoiceReconvertCryptoAndSendEmailPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/merchant/invoice/reconvert_crypto_and_send_email"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.unibeeApiMerchantInvoiceReconvertCryptoAndSendReq == nil {
		return localVarReturnValue, nil, reportError("unibeeApiMerchantInvoiceReconvertCryptoAndSendReq is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.unibeeApiMerchantInvoiceReconvertCryptoAndSendReq
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type InvoiceInvoiceRefundPostRequest struct {
	ctx context.Context
	ApiService *InvoiceService
	unibeeApiMerchantInvoiceRefundReq *UnibeeApiMerchantInvoiceRefundReq
}

func (r InvoiceInvoiceRefundPostRequest) UnibeeApiMerchantInvoiceRefundReq(unibeeApiMerchantInvoiceRefundReq UnibeeApiMerchantInvoiceRefundReq) InvoiceInvoiceRefundPostRequest {
	r.unibeeApiMerchantInvoiceRefundReq = &unibeeApiMerchantInvoiceRefundReq
	return r
}

func (r InvoiceInvoiceRefundPostRequest) Execute() (*MerchantInvoiceMarkRefundPost200Response, *http.Response, error) {
	return r.ApiService.InvoiceRefundPostExecute(r)
}

/*
InvoiceRefundPost Admin Create Refund For Invoice

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return InvoiceInvoiceRefundPostRequest
*/
func (a *InvoiceService) InvoiceRefundPost(ctx context.Context) InvoiceInvoiceRefundPostRequest {
	return InvoiceInvoiceRefundPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MerchantInvoiceMarkRefundPost200Response
func (a *InvoiceService) InvoiceRefundPostExecute(r InvoiceInvoiceRefundPostRequest) (*MerchantInvoiceMarkRefundPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MerchantInvoiceMarkRefundPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InvoiceService.InvoiceRefundPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/merchant/invoice/refund"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.unibeeApiMerchantInvoiceRefundReq == nil {
		return localVarReturnValue, nil, reportError("unibeeApiMerchantInvoiceRefundReq is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.unibeeApiMerchantInvoiceRefundReq
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type InvoiceInvoiceSendEmailPostRequest struct {
	ctx context.Context
	ApiService *InvoiceService
	unibeeApiMerchantInvoiceSendEmailReq *UnibeeApiMerchantInvoiceSendEmailReq
}

func (r InvoiceInvoiceSendEmailPostRequest) UnibeeApiMerchantInvoiceSendEmailReq(unibeeApiMerchantInvoiceSendEmailReq UnibeeApiMerchantInvoiceSendEmailReq) InvoiceInvoiceSendEmailPostRequest {
	r.unibeeApiMerchantInvoiceSendEmailReq = &unibeeApiMerchantInvoiceSendEmailReq
	return r
}

func (r InvoiceInvoiceSendEmailPostRequest) Execute() (*MerchantAuthSsoLoginOTPPost200Response, *http.Response, error) {
	return r.ApiService.InvoiceSendEmailPostExecute(r)
}

/*
InvoiceSendEmailPost Admin Send Merchant Invoice Email to User

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return InvoiceInvoiceSendEmailPostRequest
*/
func (a *InvoiceService) InvoiceSendEmailPost(ctx context.Context) InvoiceInvoiceSendEmailPostRequest {
	return InvoiceInvoiceSendEmailPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MerchantAuthSsoLoginOTPPost200Response
func (a *InvoiceService) InvoiceSendEmailPostExecute(r InvoiceInvoiceSendEmailPostRequest) (*MerchantAuthSsoLoginOTPPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MerchantAuthSsoLoginOTPPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InvoiceService.InvoiceSendEmailPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/merchant/invoice/send_email"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.unibeeApiMerchantInvoiceSendEmailReq == nil {
		return localVarReturnValue, nil, reportError("unibeeApiMerchantInvoiceSendEmailReq is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.unibeeApiMerchantInvoiceSendEmailReq
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
