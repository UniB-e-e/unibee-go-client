/*
OpenAPI UniBee

This is UniBee api server, For this sample, you can use the api key `EUXAgwv3Vcr1PFWt2SgBumMHXn3ImBqM` to test the authorization filters

API version: 
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"reflect"
)


// MerchantInvoiceAPIService MerchantInvoiceAPI service
type MerchantInvoiceAPIService service

type ApiMerchantInvoiceCancelPostRequest struct {
	ctx context.Context
	ApiService *MerchantInvoiceAPIService
	unibeeApiMerchantInvoiceCancelReq *UnibeeApiMerchantInvoiceCancelReq
}

func (r ApiMerchantInvoiceCancelPostRequest) UnibeeApiMerchantInvoiceCancelReq(unibeeApiMerchantInvoiceCancelReq UnibeeApiMerchantInvoiceCancelReq) ApiMerchantInvoiceCancelPostRequest {
	r.unibeeApiMerchantInvoiceCancelReq = &unibeeApiMerchantInvoiceCancelReq
	return r
}

func (r ApiMerchantInvoiceCancelPostRequest) Execute() (*MerchantAuthSsoLoginOTPPost200Response, *http.Response, error) {
	return r.ApiService.MerchantInvoiceCancelPostExecute(r)
}

/*
MerchantInvoiceCancelPost Admin Cancel Invoice Of Processing Status

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMerchantInvoiceCancelPostRequest
*/
func (a *MerchantInvoiceAPIService) MerchantInvoiceCancelPost(ctx context.Context) ApiMerchantInvoiceCancelPostRequest {
	return ApiMerchantInvoiceCancelPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MerchantAuthSsoLoginOTPPost200Response
func (a *MerchantInvoiceAPIService) MerchantInvoiceCancelPostExecute(r ApiMerchantInvoiceCancelPostRequest) (*MerchantAuthSsoLoginOTPPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MerchantAuthSsoLoginOTPPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MerchantInvoiceAPIService.MerchantInvoiceCancelPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/merchant/invoice/cancel"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.unibeeApiMerchantInvoiceCancelReq == nil {
		return localVarReturnValue, nil, reportError("unibeeApiMerchantInvoiceCancelReq is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.unibeeApiMerchantInvoiceCancelReq
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMerchantInvoiceDeletePostRequest struct {
	ctx context.Context
	ApiService *MerchantInvoiceAPIService
	unibeeApiMerchantInvoiceDeleteReq *UnibeeApiMerchantInvoiceDeleteReq
}

func (r ApiMerchantInvoiceDeletePostRequest) UnibeeApiMerchantInvoiceDeleteReq(unibeeApiMerchantInvoiceDeleteReq UnibeeApiMerchantInvoiceDeleteReq) ApiMerchantInvoiceDeletePostRequest {
	r.unibeeApiMerchantInvoiceDeleteReq = &unibeeApiMerchantInvoiceDeleteReq
	return r
}

func (r ApiMerchantInvoiceDeletePostRequest) Execute() (*MerchantAuthSsoLoginOTPPost200Response, *http.Response, error) {
	return r.ApiService.MerchantInvoiceDeletePostExecute(r)
}

/*
MerchantInvoiceDeletePost Admin Delete Invoice Of Pending Status

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMerchantInvoiceDeletePostRequest
*/
func (a *MerchantInvoiceAPIService) MerchantInvoiceDeletePost(ctx context.Context) ApiMerchantInvoiceDeletePostRequest {
	return ApiMerchantInvoiceDeletePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MerchantAuthSsoLoginOTPPost200Response
func (a *MerchantInvoiceAPIService) MerchantInvoiceDeletePostExecute(r ApiMerchantInvoiceDeletePostRequest) (*MerchantAuthSsoLoginOTPPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MerchantAuthSsoLoginOTPPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MerchantInvoiceAPIService.MerchantInvoiceDeletePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/merchant/invoice/delete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.unibeeApiMerchantInvoiceDeleteReq == nil {
		return localVarReturnValue, nil, reportError("unibeeApiMerchantInvoiceDeleteReq is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.unibeeApiMerchantInvoiceDeleteReq
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMerchantInvoiceDetailGetRequest struct {
	ctx context.Context
	ApiService *MerchantInvoiceAPIService
	invoiceId *string
}

// Invoice ID
func (r ApiMerchantInvoiceDetailGetRequest) InvoiceId(invoiceId string) ApiMerchantInvoiceDetailGetRequest {
	r.invoiceId = &invoiceId
	return r
}

func (r ApiMerchantInvoiceDetailGetRequest) Execute() (*MerchantInvoiceDetailGet200Response, *http.Response, error) {
	return r.ApiService.MerchantInvoiceDetailGetExecute(r)
}

/*
MerchantInvoiceDetailGet Invoice Detail

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMerchantInvoiceDetailGetRequest
*/
func (a *MerchantInvoiceAPIService) MerchantInvoiceDetailGet(ctx context.Context) ApiMerchantInvoiceDetailGetRequest {
	return ApiMerchantInvoiceDetailGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MerchantInvoiceDetailGet200Response
func (a *MerchantInvoiceAPIService) MerchantInvoiceDetailGetExecute(r ApiMerchantInvoiceDetailGetRequest) (*MerchantInvoiceDetailGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MerchantInvoiceDetailGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MerchantInvoiceAPIService.MerchantInvoiceDetailGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/merchant/invoice/detail"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.invoiceId == nil {
		return localVarReturnValue, nil, reportError("invoiceId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "invoiceId", r.invoiceId, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMerchantInvoiceDetailPostRequest struct {
	ctx context.Context
	ApiService *MerchantInvoiceAPIService
	unibeeApiMerchantInvoiceDetailReq *UnibeeApiMerchantInvoiceDetailReq
}

func (r ApiMerchantInvoiceDetailPostRequest) UnibeeApiMerchantInvoiceDetailReq(unibeeApiMerchantInvoiceDetailReq UnibeeApiMerchantInvoiceDetailReq) ApiMerchantInvoiceDetailPostRequest {
	r.unibeeApiMerchantInvoiceDetailReq = &unibeeApiMerchantInvoiceDetailReq
	return r
}

func (r ApiMerchantInvoiceDetailPostRequest) Execute() (*MerchantInvoiceDetailGet200Response, *http.Response, error) {
	return r.ApiService.MerchantInvoiceDetailPostExecute(r)
}

/*
MerchantInvoiceDetailPost Invoice Detail

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMerchantInvoiceDetailPostRequest
*/
func (a *MerchantInvoiceAPIService) MerchantInvoiceDetailPost(ctx context.Context) ApiMerchantInvoiceDetailPostRequest {
	return ApiMerchantInvoiceDetailPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MerchantInvoiceDetailGet200Response
func (a *MerchantInvoiceAPIService) MerchantInvoiceDetailPostExecute(r ApiMerchantInvoiceDetailPostRequest) (*MerchantInvoiceDetailGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MerchantInvoiceDetailGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MerchantInvoiceAPIService.MerchantInvoiceDetailPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/merchant/invoice/detail"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.unibeeApiMerchantInvoiceDetailReq == nil {
		return localVarReturnValue, nil, reportError("unibeeApiMerchantInvoiceDetailReq is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.unibeeApiMerchantInvoiceDetailReq
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMerchantInvoiceEditPostRequest struct {
	ctx context.Context
	ApiService *MerchantInvoiceAPIService
	unibeeApiMerchantInvoiceEditReq *UnibeeApiMerchantInvoiceEditReq
}

func (r ApiMerchantInvoiceEditPostRequest) UnibeeApiMerchantInvoiceEditReq(unibeeApiMerchantInvoiceEditReq UnibeeApiMerchantInvoiceEditReq) ApiMerchantInvoiceEditPostRequest {
	r.unibeeApiMerchantInvoiceEditReq = &unibeeApiMerchantInvoiceEditReq
	return r
}

func (r ApiMerchantInvoiceEditPostRequest) Execute() (*MerchantInvoiceDetailGet200Response, *http.Response, error) {
	return r.ApiService.MerchantInvoiceEditPostExecute(r)
}

/*
MerchantInvoiceEditPost Admin Edit Invoice

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMerchantInvoiceEditPostRequest
*/
func (a *MerchantInvoiceAPIService) MerchantInvoiceEditPost(ctx context.Context) ApiMerchantInvoiceEditPostRequest {
	return ApiMerchantInvoiceEditPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MerchantInvoiceDetailGet200Response
func (a *MerchantInvoiceAPIService) MerchantInvoiceEditPostExecute(r ApiMerchantInvoiceEditPostRequest) (*MerchantInvoiceDetailGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MerchantInvoiceDetailGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MerchantInvoiceAPIService.MerchantInvoiceEditPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/merchant/invoice/edit"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.unibeeApiMerchantInvoiceEditReq == nil {
		return localVarReturnValue, nil, reportError("unibeeApiMerchantInvoiceEditReq is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.unibeeApiMerchantInvoiceEditReq
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMerchantInvoiceFinishPostRequest struct {
	ctx context.Context
	ApiService *MerchantInvoiceAPIService
	unibeeApiMerchantInvoiceFinishReq *UnibeeApiMerchantInvoiceFinishReq
}

func (r ApiMerchantInvoiceFinishPostRequest) UnibeeApiMerchantInvoiceFinishReq(unibeeApiMerchantInvoiceFinishReq UnibeeApiMerchantInvoiceFinishReq) ApiMerchantInvoiceFinishPostRequest {
	r.unibeeApiMerchantInvoiceFinishReq = &unibeeApiMerchantInvoiceFinishReq
	return r
}

func (r ApiMerchantInvoiceFinishPostRequest) Execute() (*MerchantInvoiceFinishPost200Response, *http.Response, error) {
	return r.ApiService.MerchantInvoiceFinishPostExecute(r)
}

/*
MerchantInvoiceFinishPost Admin Finish Invoice，Generate Pay Link

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMerchantInvoiceFinishPostRequest
*/
func (a *MerchantInvoiceAPIService) MerchantInvoiceFinishPost(ctx context.Context) ApiMerchantInvoiceFinishPostRequest {
	return ApiMerchantInvoiceFinishPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MerchantInvoiceFinishPost200Response
func (a *MerchantInvoiceAPIService) MerchantInvoiceFinishPostExecute(r ApiMerchantInvoiceFinishPostRequest) (*MerchantInvoiceFinishPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MerchantInvoiceFinishPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MerchantInvoiceAPIService.MerchantInvoiceFinishPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/merchant/invoice/finish"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.unibeeApiMerchantInvoiceFinishReq == nil {
		return localVarReturnValue, nil, reportError("unibeeApiMerchantInvoiceFinishReq is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.unibeeApiMerchantInvoiceFinishReq
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMerchantInvoiceListGetRequest struct {
	ctx context.Context
	ApiService *MerchantInvoiceAPIService
	firstName *string
	lastName *string
	currency *string
	status *[]int32
	amountStart *int64
	amountEnd *int64
	userId *int32
	sendEmail *string
	sortField *string
	sortType *string
	deleteInclude *bool
	page *int32
	count *int32
}

// FirstName
func (r ApiMerchantInvoiceListGetRequest) FirstName(firstName string) ApiMerchantInvoiceListGetRequest {
	r.firstName = &firstName
	return r
}

// LastName
func (r ApiMerchantInvoiceListGetRequest) LastName(lastName string) ApiMerchantInvoiceListGetRequest {
	r.lastName = &lastName
	return r
}

// Currency
func (r ApiMerchantInvoiceListGetRequest) Currency(currency string) ApiMerchantInvoiceListGetRequest {
	r.currency = &currency
	return r
}

// Status, 1-pending｜2-processing｜3-paid | 4-failed | 5-cancelled
func (r ApiMerchantInvoiceListGetRequest) Status(status []int32) ApiMerchantInvoiceListGetRequest {
	r.status = &status
	return r
}

// AmountStart
func (r ApiMerchantInvoiceListGetRequest) AmountStart(amountStart int64) ApiMerchantInvoiceListGetRequest {
	r.amountStart = &amountStart
	return r
}

// AmountEnd
func (r ApiMerchantInvoiceListGetRequest) AmountEnd(amountEnd int64) ApiMerchantInvoiceListGetRequest {
	r.amountEnd = &amountEnd
	return r
}

// UserId Filter, Default Filter All
func (r ApiMerchantInvoiceListGetRequest) UserId(userId int32) ApiMerchantInvoiceListGetRequest {
	r.userId = &userId
	return r
}

// SendEmail Filter , Default Filter All
func (r ApiMerchantInvoiceListGetRequest) SendEmail(sendEmail string) ApiMerchantInvoiceListGetRequest {
	r.sendEmail = &sendEmail
	return r
}

// Filter，em. invoice_id|gmt_create|gmt_modify|period_end|total_amount，Default gmt_modify
func (r ApiMerchantInvoiceListGetRequest) SortField(sortField string) ApiMerchantInvoiceListGetRequest {
	r.sortField = &sortField
	return r
}

// Sort，asc|desc，Default desc
func (r ApiMerchantInvoiceListGetRequest) SortType(sortType string) ApiMerchantInvoiceListGetRequest {
	r.sortType = &sortType
	return r
}

// Deleted Involved，Need Admin
func (r ApiMerchantInvoiceListGetRequest) DeleteInclude(deleteInclude bool) ApiMerchantInvoiceListGetRequest {
	r.deleteInclude = &deleteInclude
	return r
}

// Page, Start 0
func (r ApiMerchantInvoiceListGetRequest) Page(page int32) ApiMerchantInvoiceListGetRequest {
	r.page = &page
	return r
}

// Count By Page
func (r ApiMerchantInvoiceListGetRequest) Count(count int32) ApiMerchantInvoiceListGetRequest {
	r.count = &count
	return r
}

func (r ApiMerchantInvoiceListGetRequest) Execute() (*MerchantInvoiceListGet200Response, *http.Response, error) {
	return r.ApiService.MerchantInvoiceListGetExecute(r)
}

/*
MerchantInvoiceListGet Invoice List

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMerchantInvoiceListGetRequest
*/
func (a *MerchantInvoiceAPIService) MerchantInvoiceListGet(ctx context.Context) ApiMerchantInvoiceListGetRequest {
	return ApiMerchantInvoiceListGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MerchantInvoiceListGet200Response
func (a *MerchantInvoiceAPIService) MerchantInvoiceListGetExecute(r ApiMerchantInvoiceListGetRequest) (*MerchantInvoiceListGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MerchantInvoiceListGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MerchantInvoiceAPIService.MerchantInvoiceListGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/merchant/invoice/list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.firstName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "firstName", r.firstName, "")
	}
	if r.lastName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lastName", r.lastName, "")
	}
	if r.currency != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currency", r.currency, "")
	}
	if r.status != nil {
		t := *r.status
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status", t, "multi")
		}
	}
	if r.amountStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "amountStart", r.amountStart, "")
	}
	if r.amountEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "amountEnd", r.amountEnd, "")
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userId", r.userId, "")
	}
	if r.sendEmail != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sendEmail", r.sendEmail, "")
	}
	if r.sortField != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortField", r.sortField, "")
	}
	if r.sortType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortType", r.sortType, "")
	}
	if r.deleteInclude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deleteInclude", r.deleteInclude, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMerchantInvoiceListPostRequest struct {
	ctx context.Context
	ApiService *MerchantInvoiceAPIService
	unibeeApiMerchantInvoiceListReq *UnibeeApiMerchantInvoiceListReq
}

func (r ApiMerchantInvoiceListPostRequest) UnibeeApiMerchantInvoiceListReq(unibeeApiMerchantInvoiceListReq UnibeeApiMerchantInvoiceListReq) ApiMerchantInvoiceListPostRequest {
	r.unibeeApiMerchantInvoiceListReq = &unibeeApiMerchantInvoiceListReq
	return r
}

func (r ApiMerchantInvoiceListPostRequest) Execute() (*MerchantInvoiceListGet200Response, *http.Response, error) {
	return r.ApiService.MerchantInvoiceListPostExecute(r)
}

/*
MerchantInvoiceListPost Invoice List

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMerchantInvoiceListPostRequest
*/
func (a *MerchantInvoiceAPIService) MerchantInvoiceListPost(ctx context.Context) ApiMerchantInvoiceListPostRequest {
	return ApiMerchantInvoiceListPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MerchantInvoiceListGet200Response
func (a *MerchantInvoiceAPIService) MerchantInvoiceListPostExecute(r ApiMerchantInvoiceListPostRequest) (*MerchantInvoiceListGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MerchantInvoiceListGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MerchantInvoiceAPIService.MerchantInvoiceListPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/merchant/invoice/list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.unibeeApiMerchantInvoiceListReq == nil {
		return localVarReturnValue, nil, reportError("unibeeApiMerchantInvoiceListReq is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.unibeeApiMerchantInvoiceListReq
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMerchantInvoiceNewPostRequest struct {
	ctx context.Context
	ApiService *MerchantInvoiceAPIService
	unibeeApiMerchantInvoiceNewReq *UnibeeApiMerchantInvoiceNewReq
}

func (r ApiMerchantInvoiceNewPostRequest) UnibeeApiMerchantInvoiceNewReq(unibeeApiMerchantInvoiceNewReq UnibeeApiMerchantInvoiceNewReq) ApiMerchantInvoiceNewPostRequest {
	r.unibeeApiMerchantInvoiceNewReq = &unibeeApiMerchantInvoiceNewReq
	return r
}

func (r ApiMerchantInvoiceNewPostRequest) Execute() (*MerchantInvoiceDetailGet200Response, *http.Response, error) {
	return r.ApiService.MerchantInvoiceNewPostExecute(r)
}

/*
MerchantInvoiceNewPost Admin Create New Invoice

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMerchantInvoiceNewPostRequest
*/
func (a *MerchantInvoiceAPIService) MerchantInvoiceNewPost(ctx context.Context) ApiMerchantInvoiceNewPostRequest {
	return ApiMerchantInvoiceNewPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MerchantInvoiceDetailGet200Response
func (a *MerchantInvoiceAPIService) MerchantInvoiceNewPostExecute(r ApiMerchantInvoiceNewPostRequest) (*MerchantInvoiceDetailGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MerchantInvoiceDetailGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MerchantInvoiceAPIService.MerchantInvoiceNewPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/merchant/invoice/new"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.unibeeApiMerchantInvoiceNewReq == nil {
		return localVarReturnValue, nil, reportError("unibeeApiMerchantInvoiceNewReq is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.unibeeApiMerchantInvoiceNewReq
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMerchantInvoicePdfGeneratePostRequest struct {
	ctx context.Context
	ApiService *MerchantInvoiceAPIService
	unibeeApiMerchantInvoicePdfGenerateReq *UnibeeApiMerchantInvoicePdfGenerateReq
}

func (r ApiMerchantInvoicePdfGeneratePostRequest) UnibeeApiMerchantInvoicePdfGenerateReq(unibeeApiMerchantInvoicePdfGenerateReq UnibeeApiMerchantInvoicePdfGenerateReq) ApiMerchantInvoicePdfGeneratePostRequest {
	r.unibeeApiMerchantInvoicePdfGenerateReq = &unibeeApiMerchantInvoicePdfGenerateReq
	return r
}

func (r ApiMerchantInvoicePdfGeneratePostRequest) Execute() (*MerchantAuthSsoLoginOTPPost200Response, *http.Response, error) {
	return r.ApiService.MerchantInvoicePdfGeneratePostExecute(r)
}

/*
MerchantInvoicePdfGeneratePost Admin Generate Merchant Invoice pdf

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMerchantInvoicePdfGeneratePostRequest
*/
func (a *MerchantInvoiceAPIService) MerchantInvoicePdfGeneratePost(ctx context.Context) ApiMerchantInvoicePdfGeneratePostRequest {
	return ApiMerchantInvoicePdfGeneratePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MerchantAuthSsoLoginOTPPost200Response
func (a *MerchantInvoiceAPIService) MerchantInvoicePdfGeneratePostExecute(r ApiMerchantInvoicePdfGeneratePostRequest) (*MerchantAuthSsoLoginOTPPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MerchantAuthSsoLoginOTPPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MerchantInvoiceAPIService.MerchantInvoicePdfGeneratePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/merchant/invoice/pdf_generate"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.unibeeApiMerchantInvoicePdfGenerateReq == nil {
		return localVarReturnValue, nil, reportError("unibeeApiMerchantInvoicePdfGenerateReq is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.unibeeApiMerchantInvoicePdfGenerateReq
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMerchantInvoiceRefundPostRequest struct {
	ctx context.Context
	ApiService *MerchantInvoiceAPIService
	unibeeApiMerchantInvoiceRefundReq *UnibeeApiMerchantInvoiceRefundReq
}

func (r ApiMerchantInvoiceRefundPostRequest) UnibeeApiMerchantInvoiceRefundReq(unibeeApiMerchantInvoiceRefundReq UnibeeApiMerchantInvoiceRefundReq) ApiMerchantInvoiceRefundPostRequest {
	r.unibeeApiMerchantInvoiceRefundReq = &unibeeApiMerchantInvoiceRefundReq
	return r
}

func (r ApiMerchantInvoiceRefundPostRequest) Execute() (*MerchantInvoiceRefundPost200Response, *http.Response, error) {
	return r.ApiService.MerchantInvoiceRefundPostExecute(r)
}

/*
MerchantInvoiceRefundPost Admin Create Refund From Invoice

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMerchantInvoiceRefundPostRequest
*/
func (a *MerchantInvoiceAPIService) MerchantInvoiceRefundPost(ctx context.Context) ApiMerchantInvoiceRefundPostRequest {
	return ApiMerchantInvoiceRefundPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MerchantInvoiceRefundPost200Response
func (a *MerchantInvoiceAPIService) MerchantInvoiceRefundPostExecute(r ApiMerchantInvoiceRefundPostRequest) (*MerchantInvoiceRefundPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MerchantInvoiceRefundPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MerchantInvoiceAPIService.MerchantInvoiceRefundPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/merchant/invoice/refund"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.unibeeApiMerchantInvoiceRefundReq == nil {
		return localVarReturnValue, nil, reportError("unibeeApiMerchantInvoiceRefundReq is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.unibeeApiMerchantInvoiceRefundReq
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMerchantInvoiceSendEmailPostRequest struct {
	ctx context.Context
	ApiService *MerchantInvoiceAPIService
	unibeeApiMerchantInvoiceSendEmailReq *UnibeeApiMerchantInvoiceSendEmailReq
}

func (r ApiMerchantInvoiceSendEmailPostRequest) UnibeeApiMerchantInvoiceSendEmailReq(unibeeApiMerchantInvoiceSendEmailReq UnibeeApiMerchantInvoiceSendEmailReq) ApiMerchantInvoiceSendEmailPostRequest {
	r.unibeeApiMerchantInvoiceSendEmailReq = &unibeeApiMerchantInvoiceSendEmailReq
	return r
}

func (r ApiMerchantInvoiceSendEmailPostRequest) Execute() (*MerchantAuthSsoLoginOTPPost200Response, *http.Response, error) {
	return r.ApiService.MerchantInvoiceSendEmailPostExecute(r)
}

/*
MerchantInvoiceSendEmailPost Admin Send Merchant Invoice Email to User

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMerchantInvoiceSendEmailPostRequest
*/
func (a *MerchantInvoiceAPIService) MerchantInvoiceSendEmailPost(ctx context.Context) ApiMerchantInvoiceSendEmailPostRequest {
	return ApiMerchantInvoiceSendEmailPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MerchantAuthSsoLoginOTPPost200Response
func (a *MerchantInvoiceAPIService) MerchantInvoiceSendEmailPostExecute(r ApiMerchantInvoiceSendEmailPostRequest) (*MerchantAuthSsoLoginOTPPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MerchantAuthSsoLoginOTPPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MerchantInvoiceAPIService.MerchantInvoiceSendEmailPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/merchant/invoice/send_email"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.unibeeApiMerchantInvoiceSendEmailReq == nil {
		return localVarReturnValue, nil, reportError("unibeeApiMerchantInvoiceSendEmailReq is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.unibeeApiMerchantInvoiceSendEmailReq
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
