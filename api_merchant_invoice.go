/*
OpenAPI UniBee

This is UniBee api server, For this sample, you can use the api key `EUXAgwv3Vcr1PFWt2SgBumMHXn3ImBqM` to test the authorization filters

API version: 
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"reflect"
)


// MerchantInvoiceAPIService MerchantInvoiceAPI service
type MerchantInvoiceAPIService service

type MerchantInvoiceAPIMerchantInvoiceCancelPostRequest struct {
	ctx context.Context
	ApiService *MerchantInvoiceAPIService
	unibeeApiMerchantInvoiceCancelReq *UnibeeApiMerchantInvoiceCancelReq
}

func (r MerchantInvoiceAPIMerchantInvoiceCancelPostRequest) UnibeeApiMerchantInvoiceCancelReq(unibeeApiMerchantInvoiceCancelReq UnibeeApiMerchantInvoiceCancelReq) MerchantInvoiceAPIMerchantInvoiceCancelPostRequest {
	r.unibeeApiMerchantInvoiceCancelReq = &unibeeApiMerchantInvoiceCancelReq
	return r
}

func (r MerchantInvoiceAPIMerchantInvoiceCancelPostRequest) Execute() (*MerchantAuthSsoLoginOTPPost200Response, *http.Response, error) {
	return r.ApiService.MerchantInvoiceCancelPostExecute(r)
}

/*
MerchantInvoiceCancelPost Admin Cancel Invoice Of Processing Status

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MerchantInvoiceAPIMerchantInvoiceCancelPostRequest
*/
func (a *MerchantInvoiceAPIService) MerchantInvoiceCancelPost(ctx context.Context) MerchantInvoiceAPIMerchantInvoiceCancelPostRequest {
	return MerchantInvoiceAPIMerchantInvoiceCancelPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MerchantAuthSsoLoginOTPPost200Response
func (a *MerchantInvoiceAPIService) MerchantInvoiceCancelPostExecute(r MerchantInvoiceAPIMerchantInvoiceCancelPostRequest) (*MerchantAuthSsoLoginOTPPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MerchantAuthSsoLoginOTPPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MerchantInvoiceAPIService.MerchantInvoiceCancelPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/merchant/invoice/cancel"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.unibeeApiMerchantInvoiceCancelReq == nil {
		return localVarReturnValue, nil, reportError("unibeeApiMerchantInvoiceCancelReq is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.unibeeApiMerchantInvoiceCancelReq
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MerchantInvoiceAPIMerchantInvoiceDeletePostRequest struct {
	ctx context.Context
	ApiService *MerchantInvoiceAPIService
	unibeeApiMerchantInvoiceDeleteReq *UnibeeApiMerchantInvoiceDeleteReq
}

func (r MerchantInvoiceAPIMerchantInvoiceDeletePostRequest) UnibeeApiMerchantInvoiceDeleteReq(unibeeApiMerchantInvoiceDeleteReq UnibeeApiMerchantInvoiceDeleteReq) MerchantInvoiceAPIMerchantInvoiceDeletePostRequest {
	r.unibeeApiMerchantInvoiceDeleteReq = &unibeeApiMerchantInvoiceDeleteReq
	return r
}

func (r MerchantInvoiceAPIMerchantInvoiceDeletePostRequest) Execute() (*MerchantAuthSsoLoginOTPPost200Response, *http.Response, error) {
	return r.ApiService.MerchantInvoiceDeletePostExecute(r)
}

/*
MerchantInvoiceDeletePost Admin Delete Invoice Of Pending Status

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MerchantInvoiceAPIMerchantInvoiceDeletePostRequest
*/
func (a *MerchantInvoiceAPIService) MerchantInvoiceDeletePost(ctx context.Context) MerchantInvoiceAPIMerchantInvoiceDeletePostRequest {
	return MerchantInvoiceAPIMerchantInvoiceDeletePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MerchantAuthSsoLoginOTPPost200Response
func (a *MerchantInvoiceAPIService) MerchantInvoiceDeletePostExecute(r MerchantInvoiceAPIMerchantInvoiceDeletePostRequest) (*MerchantAuthSsoLoginOTPPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MerchantAuthSsoLoginOTPPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MerchantInvoiceAPIService.MerchantInvoiceDeletePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/merchant/invoice/delete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.unibeeApiMerchantInvoiceDeleteReq == nil {
		return localVarReturnValue, nil, reportError("unibeeApiMerchantInvoiceDeleteReq is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.unibeeApiMerchantInvoiceDeleteReq
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MerchantInvoiceAPIMerchantInvoiceDetailGetRequest struct {
	ctx context.Context
	ApiService *MerchantInvoiceAPIService
	invoiceId *string
}

// Invoice ID
func (r MerchantInvoiceAPIMerchantInvoiceDetailGetRequest) InvoiceId(invoiceId string) MerchantInvoiceAPIMerchantInvoiceDetailGetRequest {
	r.invoiceId = &invoiceId
	return r
}

func (r MerchantInvoiceAPIMerchantInvoiceDetailGetRequest) Execute() (*MerchantInvoiceDetailGet200Response, *http.Response, error) {
	return r.ApiService.MerchantInvoiceDetailGetExecute(r)
}

/*
MerchantInvoiceDetailGet Invoice Detail

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MerchantInvoiceAPIMerchantInvoiceDetailGetRequest
*/
func (a *MerchantInvoiceAPIService) MerchantInvoiceDetailGet(ctx context.Context) MerchantInvoiceAPIMerchantInvoiceDetailGetRequest {
	return MerchantInvoiceAPIMerchantInvoiceDetailGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MerchantInvoiceDetailGet200Response
func (a *MerchantInvoiceAPIService) MerchantInvoiceDetailGetExecute(r MerchantInvoiceAPIMerchantInvoiceDetailGetRequest) (*MerchantInvoiceDetailGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MerchantInvoiceDetailGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MerchantInvoiceAPIService.MerchantInvoiceDetailGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/merchant/invoice/detail"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.invoiceId == nil {
		return localVarReturnValue, nil, reportError("invoiceId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "invoiceId", r.invoiceId, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MerchantInvoiceAPIMerchantInvoiceDetailPostRequest struct {
	ctx context.Context
	ApiService *MerchantInvoiceAPIService
	unibeeApiMerchantInvoiceDetailReq *UnibeeApiMerchantInvoiceDetailReq
}

func (r MerchantInvoiceAPIMerchantInvoiceDetailPostRequest) UnibeeApiMerchantInvoiceDetailReq(unibeeApiMerchantInvoiceDetailReq UnibeeApiMerchantInvoiceDetailReq) MerchantInvoiceAPIMerchantInvoiceDetailPostRequest {
	r.unibeeApiMerchantInvoiceDetailReq = &unibeeApiMerchantInvoiceDetailReq
	return r
}

func (r MerchantInvoiceAPIMerchantInvoiceDetailPostRequest) Execute() (*MerchantInvoiceDetailGet200Response, *http.Response, error) {
	return r.ApiService.MerchantInvoiceDetailPostExecute(r)
}

/*
MerchantInvoiceDetailPost Invoice Detail

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MerchantInvoiceAPIMerchantInvoiceDetailPostRequest
*/
func (a *MerchantInvoiceAPIService) MerchantInvoiceDetailPost(ctx context.Context) MerchantInvoiceAPIMerchantInvoiceDetailPostRequest {
	return MerchantInvoiceAPIMerchantInvoiceDetailPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MerchantInvoiceDetailGet200Response
func (a *MerchantInvoiceAPIService) MerchantInvoiceDetailPostExecute(r MerchantInvoiceAPIMerchantInvoiceDetailPostRequest) (*MerchantInvoiceDetailGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MerchantInvoiceDetailGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MerchantInvoiceAPIService.MerchantInvoiceDetailPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/merchant/invoice/detail"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.unibeeApiMerchantInvoiceDetailReq == nil {
		return localVarReturnValue, nil, reportError("unibeeApiMerchantInvoiceDetailReq is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.unibeeApiMerchantInvoiceDetailReq
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MerchantInvoiceAPIMerchantInvoiceEditPostRequest struct {
	ctx context.Context
	ApiService *MerchantInvoiceAPIService
	unibeeApiMerchantInvoiceEditReq *UnibeeApiMerchantInvoiceEditReq
}

func (r MerchantInvoiceAPIMerchantInvoiceEditPostRequest) UnibeeApiMerchantInvoiceEditReq(unibeeApiMerchantInvoiceEditReq UnibeeApiMerchantInvoiceEditReq) MerchantInvoiceAPIMerchantInvoiceEditPostRequest {
	r.unibeeApiMerchantInvoiceEditReq = &unibeeApiMerchantInvoiceEditReq
	return r
}

func (r MerchantInvoiceAPIMerchantInvoiceEditPostRequest) Execute() (*MerchantInvoiceDetailGet200Response, *http.Response, error) {
	return r.ApiService.MerchantInvoiceEditPostExecute(r)
}

/*
MerchantInvoiceEditPost Admin Edit Invoice

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MerchantInvoiceAPIMerchantInvoiceEditPostRequest
*/
func (a *MerchantInvoiceAPIService) MerchantInvoiceEditPost(ctx context.Context) MerchantInvoiceAPIMerchantInvoiceEditPostRequest {
	return MerchantInvoiceAPIMerchantInvoiceEditPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MerchantInvoiceDetailGet200Response
func (a *MerchantInvoiceAPIService) MerchantInvoiceEditPostExecute(r MerchantInvoiceAPIMerchantInvoiceEditPostRequest) (*MerchantInvoiceDetailGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MerchantInvoiceDetailGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MerchantInvoiceAPIService.MerchantInvoiceEditPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/merchant/invoice/edit"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.unibeeApiMerchantInvoiceEditReq == nil {
		return localVarReturnValue, nil, reportError("unibeeApiMerchantInvoiceEditReq is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.unibeeApiMerchantInvoiceEditReq
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MerchantInvoiceAPIMerchantInvoiceFinishPostRequest struct {
	ctx context.Context
	ApiService *MerchantInvoiceAPIService
	unibeeApiMerchantInvoiceFinishReq *UnibeeApiMerchantInvoiceFinishReq
}

func (r MerchantInvoiceAPIMerchantInvoiceFinishPostRequest) UnibeeApiMerchantInvoiceFinishReq(unibeeApiMerchantInvoiceFinishReq UnibeeApiMerchantInvoiceFinishReq) MerchantInvoiceAPIMerchantInvoiceFinishPostRequest {
	r.unibeeApiMerchantInvoiceFinishReq = &unibeeApiMerchantInvoiceFinishReq
	return r
}

func (r MerchantInvoiceAPIMerchantInvoiceFinishPostRequest) Execute() (*MerchantInvoiceFinishPost200Response, *http.Response, error) {
	return r.ApiService.MerchantInvoiceFinishPostExecute(r)
}

/*
MerchantInvoiceFinishPost Admin Finish Invoice，Generate Pay Link

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MerchantInvoiceAPIMerchantInvoiceFinishPostRequest
*/
func (a *MerchantInvoiceAPIService) MerchantInvoiceFinishPost(ctx context.Context) MerchantInvoiceAPIMerchantInvoiceFinishPostRequest {
	return MerchantInvoiceAPIMerchantInvoiceFinishPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MerchantInvoiceFinishPost200Response
func (a *MerchantInvoiceAPIService) MerchantInvoiceFinishPostExecute(r MerchantInvoiceAPIMerchantInvoiceFinishPostRequest) (*MerchantInvoiceFinishPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MerchantInvoiceFinishPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MerchantInvoiceAPIService.MerchantInvoiceFinishPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/merchant/invoice/finish"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.unibeeApiMerchantInvoiceFinishReq == nil {
		return localVarReturnValue, nil, reportError("unibeeApiMerchantInvoiceFinishReq is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.unibeeApiMerchantInvoiceFinishReq
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MerchantInvoiceAPIMerchantInvoiceListGetRequest struct {
	ctx context.Context
	ApiService *MerchantInvoiceAPIService
	firstName *string
	lastName *string
	currency *string
	status *[]int32
	amountStart *int64
	amountEnd *int64
	userId *int32
	sendEmail *string
	sortField *string
	sortType *string
	deleteInclude *bool
	page *int32
	count *int32
}

// FirstName
func (r MerchantInvoiceAPIMerchantInvoiceListGetRequest) FirstName(firstName string) MerchantInvoiceAPIMerchantInvoiceListGetRequest {
	r.firstName = &firstName
	return r
}

// LastName
func (r MerchantInvoiceAPIMerchantInvoiceListGetRequest) LastName(lastName string) MerchantInvoiceAPIMerchantInvoiceListGetRequest {
	r.lastName = &lastName
	return r
}

// Currency
func (r MerchantInvoiceAPIMerchantInvoiceListGetRequest) Currency(currency string) MerchantInvoiceAPIMerchantInvoiceListGetRequest {
	r.currency = &currency
	return r
}

// Status, 1-pending｜2-processing｜3-paid | 4-failed | 5-cancelled
func (r MerchantInvoiceAPIMerchantInvoiceListGetRequest) Status(status []int32) MerchantInvoiceAPIMerchantInvoiceListGetRequest {
	r.status = &status
	return r
}

// AmountStart
func (r MerchantInvoiceAPIMerchantInvoiceListGetRequest) AmountStart(amountStart int64) MerchantInvoiceAPIMerchantInvoiceListGetRequest {
	r.amountStart = &amountStart
	return r
}

// AmountEnd
func (r MerchantInvoiceAPIMerchantInvoiceListGetRequest) AmountEnd(amountEnd int64) MerchantInvoiceAPIMerchantInvoiceListGetRequest {
	r.amountEnd = &amountEnd
	return r
}

// UserId Filter, Default Filter All
func (r MerchantInvoiceAPIMerchantInvoiceListGetRequest) UserId(userId int32) MerchantInvoiceAPIMerchantInvoiceListGetRequest {
	r.userId = &userId
	return r
}

// SendEmail Filter , Default Filter All
func (r MerchantInvoiceAPIMerchantInvoiceListGetRequest) SendEmail(sendEmail string) MerchantInvoiceAPIMerchantInvoiceListGetRequest {
	r.sendEmail = &sendEmail
	return r
}

// Filter，em. invoice_id|gmt_create|gmt_modify|period_end|total_amount，Default gmt_modify
func (r MerchantInvoiceAPIMerchantInvoiceListGetRequest) SortField(sortField string) MerchantInvoiceAPIMerchantInvoiceListGetRequest {
	r.sortField = &sortField
	return r
}

// Sort，asc|desc，Default desc
func (r MerchantInvoiceAPIMerchantInvoiceListGetRequest) SortType(sortType string) MerchantInvoiceAPIMerchantInvoiceListGetRequest {
	r.sortType = &sortType
	return r
}

// Deleted Involved，Need Admin
func (r MerchantInvoiceAPIMerchantInvoiceListGetRequest) DeleteInclude(deleteInclude bool) MerchantInvoiceAPIMerchantInvoiceListGetRequest {
	r.deleteInclude = &deleteInclude
	return r
}

// Page, Start 0
func (r MerchantInvoiceAPIMerchantInvoiceListGetRequest) Page(page int32) MerchantInvoiceAPIMerchantInvoiceListGetRequest {
	r.page = &page
	return r
}

// Count By Page
func (r MerchantInvoiceAPIMerchantInvoiceListGetRequest) Count(count int32) MerchantInvoiceAPIMerchantInvoiceListGetRequest {
	r.count = &count
	return r
}

func (r MerchantInvoiceAPIMerchantInvoiceListGetRequest) Execute() (*MerchantInvoiceListGet200Response, *http.Response, error) {
	return r.ApiService.MerchantInvoiceListGetExecute(r)
}

/*
MerchantInvoiceListGet Invoice List

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MerchantInvoiceAPIMerchantInvoiceListGetRequest
*/
func (a *MerchantInvoiceAPIService) MerchantInvoiceListGet(ctx context.Context) MerchantInvoiceAPIMerchantInvoiceListGetRequest {
	return MerchantInvoiceAPIMerchantInvoiceListGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MerchantInvoiceListGet200Response
func (a *MerchantInvoiceAPIService) MerchantInvoiceListGetExecute(r MerchantInvoiceAPIMerchantInvoiceListGetRequest) (*MerchantInvoiceListGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MerchantInvoiceListGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MerchantInvoiceAPIService.MerchantInvoiceListGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/merchant/invoice/list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.firstName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "firstName", r.firstName, "")
	}
	if r.lastName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lastName", r.lastName, "")
	}
	if r.currency != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currency", r.currency, "")
	}
	if r.status != nil {
		t := *r.status
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status", t, "multi")
		}
	}
	if r.amountStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "amountStart", r.amountStart, "")
	}
	if r.amountEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "amountEnd", r.amountEnd, "")
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userId", r.userId, "")
	}
	if r.sendEmail != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sendEmail", r.sendEmail, "")
	}
	if r.sortField != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortField", r.sortField, "")
	}
	if r.sortType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortType", r.sortType, "")
	}
	if r.deleteInclude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deleteInclude", r.deleteInclude, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MerchantInvoiceAPIMerchantInvoiceListPostRequest struct {
	ctx context.Context
	ApiService *MerchantInvoiceAPIService
	unibeeApiMerchantInvoiceListReq *UnibeeApiMerchantInvoiceListReq
}

func (r MerchantInvoiceAPIMerchantInvoiceListPostRequest) UnibeeApiMerchantInvoiceListReq(unibeeApiMerchantInvoiceListReq UnibeeApiMerchantInvoiceListReq) MerchantInvoiceAPIMerchantInvoiceListPostRequest {
	r.unibeeApiMerchantInvoiceListReq = &unibeeApiMerchantInvoiceListReq
	return r
}

func (r MerchantInvoiceAPIMerchantInvoiceListPostRequest) Execute() (*MerchantInvoiceListGet200Response, *http.Response, error) {
	return r.ApiService.MerchantInvoiceListPostExecute(r)
}

/*
MerchantInvoiceListPost Invoice List

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MerchantInvoiceAPIMerchantInvoiceListPostRequest
*/
func (a *MerchantInvoiceAPIService) MerchantInvoiceListPost(ctx context.Context) MerchantInvoiceAPIMerchantInvoiceListPostRequest {
	return MerchantInvoiceAPIMerchantInvoiceListPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MerchantInvoiceListGet200Response
func (a *MerchantInvoiceAPIService) MerchantInvoiceListPostExecute(r MerchantInvoiceAPIMerchantInvoiceListPostRequest) (*MerchantInvoiceListGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MerchantInvoiceListGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MerchantInvoiceAPIService.MerchantInvoiceListPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/merchant/invoice/list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.unibeeApiMerchantInvoiceListReq == nil {
		return localVarReturnValue, nil, reportError("unibeeApiMerchantInvoiceListReq is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.unibeeApiMerchantInvoiceListReq
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MerchantInvoiceAPIMerchantInvoiceNewPostRequest struct {
	ctx context.Context
	ApiService *MerchantInvoiceAPIService
	unibeeApiMerchantInvoiceNewReq *UnibeeApiMerchantInvoiceNewReq
}

func (r MerchantInvoiceAPIMerchantInvoiceNewPostRequest) UnibeeApiMerchantInvoiceNewReq(unibeeApiMerchantInvoiceNewReq UnibeeApiMerchantInvoiceNewReq) MerchantInvoiceAPIMerchantInvoiceNewPostRequest {
	r.unibeeApiMerchantInvoiceNewReq = &unibeeApiMerchantInvoiceNewReq
	return r
}

func (r MerchantInvoiceAPIMerchantInvoiceNewPostRequest) Execute() (*MerchantInvoiceDetailGet200Response, *http.Response, error) {
	return r.ApiService.MerchantInvoiceNewPostExecute(r)
}

/*
MerchantInvoiceNewPost Admin Create New Invoice

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MerchantInvoiceAPIMerchantInvoiceNewPostRequest
*/
func (a *MerchantInvoiceAPIService) MerchantInvoiceNewPost(ctx context.Context) MerchantInvoiceAPIMerchantInvoiceNewPostRequest {
	return MerchantInvoiceAPIMerchantInvoiceNewPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MerchantInvoiceDetailGet200Response
func (a *MerchantInvoiceAPIService) MerchantInvoiceNewPostExecute(r MerchantInvoiceAPIMerchantInvoiceNewPostRequest) (*MerchantInvoiceDetailGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MerchantInvoiceDetailGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MerchantInvoiceAPIService.MerchantInvoiceNewPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/merchant/invoice/new"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.unibeeApiMerchantInvoiceNewReq == nil {
		return localVarReturnValue, nil, reportError("unibeeApiMerchantInvoiceNewReq is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.unibeeApiMerchantInvoiceNewReq
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MerchantInvoiceAPIMerchantInvoicePdfGeneratePostRequest struct {
	ctx context.Context
	ApiService *MerchantInvoiceAPIService
	unibeeApiMerchantInvoicePdfGenerateReq *UnibeeApiMerchantInvoicePdfGenerateReq
}

func (r MerchantInvoiceAPIMerchantInvoicePdfGeneratePostRequest) UnibeeApiMerchantInvoicePdfGenerateReq(unibeeApiMerchantInvoicePdfGenerateReq UnibeeApiMerchantInvoicePdfGenerateReq) MerchantInvoiceAPIMerchantInvoicePdfGeneratePostRequest {
	r.unibeeApiMerchantInvoicePdfGenerateReq = &unibeeApiMerchantInvoicePdfGenerateReq
	return r
}

func (r MerchantInvoiceAPIMerchantInvoicePdfGeneratePostRequest) Execute() (*MerchantAuthSsoLoginOTPPost200Response, *http.Response, error) {
	return r.ApiService.MerchantInvoicePdfGeneratePostExecute(r)
}

/*
MerchantInvoicePdfGeneratePost Admin Generate Merchant Invoice pdf

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MerchantInvoiceAPIMerchantInvoicePdfGeneratePostRequest
*/
func (a *MerchantInvoiceAPIService) MerchantInvoicePdfGeneratePost(ctx context.Context) MerchantInvoiceAPIMerchantInvoicePdfGeneratePostRequest {
	return MerchantInvoiceAPIMerchantInvoicePdfGeneratePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MerchantAuthSsoLoginOTPPost200Response
func (a *MerchantInvoiceAPIService) MerchantInvoicePdfGeneratePostExecute(r MerchantInvoiceAPIMerchantInvoicePdfGeneratePostRequest) (*MerchantAuthSsoLoginOTPPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MerchantAuthSsoLoginOTPPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MerchantInvoiceAPIService.MerchantInvoicePdfGeneratePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/merchant/invoice/pdf_generate"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.unibeeApiMerchantInvoicePdfGenerateReq == nil {
		return localVarReturnValue, nil, reportError("unibeeApiMerchantInvoicePdfGenerateReq is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.unibeeApiMerchantInvoicePdfGenerateReq
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MerchantInvoiceAPIMerchantInvoiceRefundPostRequest struct {
	ctx context.Context
	ApiService *MerchantInvoiceAPIService
	unibeeApiMerchantInvoiceRefundReq *UnibeeApiMerchantInvoiceRefundReq
}

func (r MerchantInvoiceAPIMerchantInvoiceRefundPostRequest) UnibeeApiMerchantInvoiceRefundReq(unibeeApiMerchantInvoiceRefundReq UnibeeApiMerchantInvoiceRefundReq) MerchantInvoiceAPIMerchantInvoiceRefundPostRequest {
	r.unibeeApiMerchantInvoiceRefundReq = &unibeeApiMerchantInvoiceRefundReq
	return r
}

func (r MerchantInvoiceAPIMerchantInvoiceRefundPostRequest) Execute() (*MerchantInvoiceRefundPost200Response, *http.Response, error) {
	return r.ApiService.MerchantInvoiceRefundPostExecute(r)
}

/*
MerchantInvoiceRefundPost Admin Create Refund From Invoice

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MerchantInvoiceAPIMerchantInvoiceRefundPostRequest
*/
func (a *MerchantInvoiceAPIService) MerchantInvoiceRefundPost(ctx context.Context) MerchantInvoiceAPIMerchantInvoiceRefundPostRequest {
	return MerchantInvoiceAPIMerchantInvoiceRefundPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MerchantInvoiceRefundPost200Response
func (a *MerchantInvoiceAPIService) MerchantInvoiceRefundPostExecute(r MerchantInvoiceAPIMerchantInvoiceRefundPostRequest) (*MerchantInvoiceRefundPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MerchantInvoiceRefundPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MerchantInvoiceAPIService.MerchantInvoiceRefundPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/merchant/invoice/refund"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.unibeeApiMerchantInvoiceRefundReq == nil {
		return localVarReturnValue, nil, reportError("unibeeApiMerchantInvoiceRefundReq is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.unibeeApiMerchantInvoiceRefundReq
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MerchantInvoiceAPIMerchantInvoiceSendEmailPostRequest struct {
	ctx context.Context
	ApiService *MerchantInvoiceAPIService
	unibeeApiMerchantInvoiceSendEmailReq *UnibeeApiMerchantInvoiceSendEmailReq
}

func (r MerchantInvoiceAPIMerchantInvoiceSendEmailPostRequest) UnibeeApiMerchantInvoiceSendEmailReq(unibeeApiMerchantInvoiceSendEmailReq UnibeeApiMerchantInvoiceSendEmailReq) MerchantInvoiceAPIMerchantInvoiceSendEmailPostRequest {
	r.unibeeApiMerchantInvoiceSendEmailReq = &unibeeApiMerchantInvoiceSendEmailReq
	return r
}

func (r MerchantInvoiceAPIMerchantInvoiceSendEmailPostRequest) Execute() (*MerchantAuthSsoLoginOTPPost200Response, *http.Response, error) {
	return r.ApiService.MerchantInvoiceSendEmailPostExecute(r)
}

/*
MerchantInvoiceSendEmailPost Admin Send Merchant Invoice Email to User

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MerchantInvoiceAPIMerchantInvoiceSendEmailPostRequest
*/
func (a *MerchantInvoiceAPIService) MerchantInvoiceSendEmailPost(ctx context.Context) MerchantInvoiceAPIMerchantInvoiceSendEmailPostRequest {
	return MerchantInvoiceAPIMerchantInvoiceSendEmailPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MerchantAuthSsoLoginOTPPost200Response
func (a *MerchantInvoiceAPIService) MerchantInvoiceSendEmailPostExecute(r MerchantInvoiceAPIMerchantInvoiceSendEmailPostRequest) (*MerchantAuthSsoLoginOTPPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MerchantAuthSsoLoginOTPPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MerchantInvoiceAPIService.MerchantInvoiceSendEmailPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/merchant/invoice/send_email"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.unibeeApiMerchantInvoiceSendEmailReq == nil {
		return localVarReturnValue, nil, reportError("unibeeApiMerchantInvoiceSendEmailReq is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.unibeeApiMerchantInvoiceSendEmailReq
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
